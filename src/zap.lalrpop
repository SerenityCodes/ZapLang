use std::str::FromStr;
use crate::ast::*;

grammar;

// ------------------------
// Grammar Rules
// ------------------------

pub Program: Program = {
    <statements:Statement*> => Program { statements }
};

Statement: Statement = {
    <f:FunctionDecl> => Statement::FunctionDecl(f),
    <s:StructDecl> => Statement::StructDecl(s),
    <c:ComponentDecl> => Statement::ComponentDecl(c),
    <m:ModuleDecl> => Statement::ModuleDecl(m),
    <v:VariableDecl> ";" => Statement::VariableDecl(v),
    <e:Expression> ";" => Statement::ExpressionStmt(e),
    <b:Block> => Statement::Block(b),
    <i:IfStmt> => Statement::IfStmt(i),
    <w:WhileStmt> => Statement::WhileStmt(w),
    <f:ForStmt> => Statement::ForStmt(f),
    <r:ReturnStmt> => Statement::ReturnStmt(r),
    <y:YieldStmt> => Statement::YieldStmt(y),
    <d:DeferStmt> => Statement::DeferStmt(d),
};

FunctionDecl: FunctionDecl = {
    <attr:AttributeBlock?> "func" <name:Identifier> "(" <params:ParameterList?> ")" <ret:ReturnType?> <body:Block> => {
        FunctionDecl {
            attributes: attr,
            name,
            parameters: params.unwrap_or_default(),
            return_type: ret,
            body,
        }
    }
};

AttributeBlock: AttributeBlock = {
    "@" <attr:AttributeWithParams> => AttributeBlock { attributes: vec![attr] },
    "@" "[" <attrs:AttributeList> "]" => AttributeBlock { attributes: attrs }
};

AttributeWithParams: String = {
    <name:Identifier> "(" <param:Identifier> ")" => format!("{}({})", name, param),
    <name:Identifier> => name,
};

AttributeList: Vec<String> = {
    <id:Identifier> => vec![id],
    <list:AttributeList> "," <id:Identifier> => {
        let mut list = list;
        list.push(id);
        list
    },
};

ReturnType: Type = {
    "->" <t:Type> => t
};

ParameterList: Vec<Parameter> = {
    <param:Parameter> => vec![param],
    <list:ParameterList> "," <param:Parameter> => {
        let mut list = list;
        list.push(param);
        list
    },
};

Parameter: Parameter = {
    <name:Identifier> ":" <param_type:Type> => Parameter { name, param_type, is_ref: false },
    <name:Identifier> ":" "ref" <param_type:Type> => Parameter { name, param_type, is_ref: true },
};

Type: Type = {
    <name:Identifier> => {
        Type {
            name,
            generic: None,
            is_array: false,
        }
    },
    <name:Identifier> "<" <inner:Type> ">" => {
        Type {
            name,
            generic: Some(Box::new(inner)),
            is_array: false,
        }
    },
    <name:Identifier> "[" "]" => {
        Type {
            name,
            generic: None,
            is_array: true,
        }
    },
    <name:Identifier> "<" <inner:Type> ">" "[" "]" => {
        Type {
            name,
            generic: Some(Box::new(inner)),
            is_array: true,
        }
    },
};

StructDecl: StructDecl = {
    "struct" <name:Identifier> "{" <fields:StructField*> "}" => {
        StructDecl { name, fields }
    }
};

StructField: StructField = {
    <name:Identifier> ":" <field_type:Type> ";" => StructField { name, field_type }
};

ComponentDecl: ComponentDecl = {
    <readonly:"readonly"?> "component" <name:Identifier> "{" <fields:StructField*> "}" => {
        ComponentDecl {
            readonly: readonly.is_some(),
            name,
            fields,
        }
    }
};

ModuleDecl: ModuleDecl = {
    "module" <name:Identifier> "{" <statements:Statement*> "}" => {
        ModuleDecl { name, statements }
    }
};

Block: Block = {
    "{" <statements:Statement*> "}" => Block { statements }
};

VariableDecl: VariableDecl = {
    "let" <name:Identifier> ":" <var_type:Type> "=" <value:VariableValue> => {
        VariableDecl { name, var_type, value }
    }
};

VariableValue: VariableValue = {
    <e:Expression> => VariableValue::Expression(e),
    <a:AotBlock> => VariableValue::AotBlock(a),
};

AotBlock: Block = {
    "aot" <b:Block> => b
};

IfStmt: IfStmt = {
    "if" "(" <condition:Expression> ")" <then_block:Block> "else" <else_block:Block> => {
        IfStmt { condition, then_block, else_block: Some(else_block) }
    },
    "if" "(" <condition:Expression> ")" <then_block:Block> => {
        IfStmt { condition, then_block, else_block: None }
    },
};

WhileStmt: WhileStmt = {
    "while" "(" <condition:Expression> ")" <body:Block> => {
        WhileStmt { condition, body }
    }
};

ForStmt: ForStmt = {
    "for" "(" <init:VariableDecl> ";" <condition:Expression> ";" <update:Expression> ")" <body:Block> => {
        ForStmt { init, condition, update, body }
    }
};

ReturnStmt: ReturnStmt = {
    "return" <value:Expression?> ";" => ReturnStmt { value }
};

YieldStmt: YieldStmt = {
    "yield" <value:Expression?> ";" => YieldStmt { value }
};

DeferStmt: DeferStmt = {
    "defer" <b:Block> => DeferStmt::Block(b),
    "defer" <e:Expression> ";" => DeferStmt::Expression(e),
};

// ------------------------
// Expression Grammar
// ------------------------

Expression: Expression = {
    Assignment
};

Assignment: Expression = {
    <left:LogicOr> "=" <right:Assignment> => Expression::Assignment(Box::new(left), Box::new(right)),
    LogicOr,
};

LogicOr: Expression = {
    <left:LogicOr> "||" <right:LogicAnd> => Expression::LogicOr(Box::new(left), Box::new(right)),
    LogicAnd,
};

LogicAnd: Expression = {
    <left:LogicAnd> "&&" <right:Equality> => Expression::LogicAnd(Box::new(left), Box::new(right)),
    Equality,
};

Equality: Expression = {
    <left:Equality> <op:EqualityOp> <right:Comparison> => {
        Expression::Equality(Box::new(left), op, Box::new(right))
    },
    Comparison,
};

EqualityOp: EqualityOp = {
    "==" => EqualityOp::Equal,
    "!=" => EqualityOp::NotEqual,
};

Comparison: Expression = {
    <left:Comparison> <op:ComparisonOp> <right:Term> => {
        Expression::Comparison(Box::new(left), op, Box::new(right))
    },
    Term,
};

ComparisonOp: ComparisonOp = {
    "<" => ComparisonOp::Less,
    "<=" => ComparisonOp::LessEqual,
    ">" => ComparisonOp::Greater,
    ">=" => ComparisonOp::GreaterEqual,
};

Term: Expression = {
    <left:Term> <op:TermOp> <right:Factor> => {
        Expression::Term(Box::new(left), op, Box::new(right))
    },
    Factor,
};

TermOp: TermOp = {
    "+" => TermOp::Add,
    "-" => TermOp::Subtract,
};

Factor: Expression = {
    <left:Factor> <op:FactorOp> <right:Unary> => {
        Expression::Factor(Box::new(left), op, Box::new(right))
    },
    Unary,
};

FactorOp: FactorOp = {
    "*" => FactorOp::Multiply,
    "/" => FactorOp::Divide,
    "%" => FactorOp::Modulo,
};

Unary: Expression = {
    <op:UnaryOp> <expr:Unary> => Expression::Unary(op, Box::new(expr)),
    Call,
};

UnaryOp: UnaryOp = {
    "!" => UnaryOp::Not,
    "-" => UnaryOp::Negate,
};

Call: Expression = {
    <expr:Call> "(" <args:ArgumentList?> ")" => {
        Expression::Call(Box::new(expr), args.unwrap_or_default())
    },
    FieldAccess,
};

FieldAccess: Expression = {
    <expr:FieldAccess> "." <field:Identifier> => {
        Expression::FieldAccess(Box::new(expr), field)
    },
    Primary,
};

ArgumentList: Vec<Expression> = {
    <expr:Expression> => vec![expr],
    <list:ArgumentList> "," <expr:Expression> => {
        let mut list = list;
        list.push(expr);
        list
    },
};

Primary: Expression = {
    <p:PrimaryValue> => Expression::Primary(p),
};

PrimaryValue: Primary = {
    <i:Integer> => Primary::Integer(i),
    <f:Float> => Primary::Float(f),
    <b:Boolean> => Primary::Boolean(b),
    <s:StringLiteral> => Primary::String(s),
    <id:Identifier> => Primary::Identifier(id),
    "(" <e:Expression> ")" => Primary::Parenthesized(Box::new(e)),
    "{" <fields:FieldInitializerList> "}" => Primary::StructLiteral(fields),
};

FieldInitializerList: Vec<FieldInitializer> = {
    <field:FieldInitializer> => vec![field],
    <list:FieldInitializerList> "," <field:FieldInitializer> => {
        let mut list = list;
        list.push(field);
        list
    },
};

FieldInitializer: FieldInitializer = {
    <name:Identifier> ":" <value:Expression> => FieldInitializer { name, value }
};

// ------------------------
// Terminals and Tokens
// ------------------------

Integer: i64 = {
    r"[0-9]+" => i64::from_str(<>).unwrap()
};

Float: f64 = {
    r"[0-9]+\.[0-9]+" => f64::from_str(<>).unwrap()
};

Boolean: bool = {
    "true" => true,
    "false" => false,
};

StringLiteral: String = {
    r#""([^"\\]|\\.)*""# => {
        // Remove quotes and handle basic escape sequences
        let s = &<>[1..<>.len()-1];
        s.replace("\\\"", "\"").replace("\\\\", "\\")
    }
};

Identifier: String = {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string()
};

// Handle whitespace and comments
match {
    r"\s*" => { }, // whitespace
    r"//[^\n\r]*[\n\r]*" => { }, // line comments 
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { }, // block comments
    _
}